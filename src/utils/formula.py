import networkx as nx


def to_int_matrix(formula):
    new_formula = []
    for i in range(len(formula)):
        line = []
        for ele in formula[i].split()[: -1]:
            line.append(int(ele))
        new_formula.append(line)
    return new_formula


def sat_to_graph(source, graph_type=None):
    cnf = open(source)
    content = cnf.readlines()
    while content[0].split()[0] == 'c':
        content = content[1:]
    while len(content[-1].split()) <= 1:
        content = content[:-1]

    # Paramters
    parameters = content[0].split()
    formula = content[1:]
    formula = to_int_matrix(formula)
    num_vars = int(parameters[2])
    num_clause = int(parameters[3])

    if graph_type == 'vig':
        return preprocess_VIG(formula, num_vars)
    elif graph_type == 'lig':
        return preprocess_LIG(formula, num_vars)
    elif graph_type == 'vcg':
        return preprocess_VCG(formula, num_vars, num_clause)
    return formula, num_vars


def preprocess_VIG(formula, num_vars):
    """
    Builds VIG.
    """
    VIG = nx.Graph()
    VIG.add_nodes_from(range(num_vars + 1)[1:])

    for cn in range(len(formula)):
        for i in range(len(formula[cn])-1):
            lit1 = formula[cn][i]
            node1 = abs(lit1)
            sign1 = 1 if lit1 > 0 else 0
            for j in range(len(formula[cn]))[i+1:]:
                lit2 = formula[cn][j]
                node2 = abs(lit2)
                sign2 = 1 if lit2 > 0 else 0
                if not VIG.has_edge(node1, node2):
                    tmp1 = tmp2 = 0
                else:
                    tmp1 = VIG.edges[node1, node2]['weight1']
                    tmp2 = VIG.edges[node1, node2]['weight2']
                if sign1 == sign2:
                    tmp1 += 1
                else:
                    tmp2 += 1
                VIG.add_edge(node1, node2, weight1=tmp1, weight2=tmp2)
    return VIG


def preprocess_LIG(formula, num_vars):
    """
    Builds LIG.
    """
    LIG = nx.Graph()
    LIG.add_nodes_from(range(2 * num_vars + 1)[1:])

    for cn in range(len(formula)):
        for i in range(len(formula[cn])-1):
            lit1 = formula[cn][i]
            node1 = abs(lit1) + num_vars if lit1 < 0 else lit1
            for j in range(len(formula[cn]))[i+1:]:
                lit2 = formula[cn][j]
                node2 = abs(lit2) + num_vars if lit2 < 0 else lit2
                weight = LIG.edges[node1, node2]['weight'] if LIG.has_edge(node1, node2) else 0
                weight += 1
                LIG.add_edge(node1, node2, weight=weight)
    return LIG


def preprocess_VCG(formula, num_vars, num_clause):
    VCG = nx.Graph()
    VCG.add_nodes_from(range(num_vars + num_clause + 1)[1:])
    for cn in range(len(formula)):
        for var in formula[cn]:
            if var > 0:
                VCG.add_edge(var, cn + num_vars + 1, weight=1)
            elif var < 0:
                VCG.add_edge(abs(var), cn + num_vars + 1, weight=-1)
    return VCG, num_vars, num_clause


def VCG_to_sat(graph, save_name, num_vars, outer_var_ptr=None):
    nodes = list(graph.nodes())
    assert (0 not in nodes)
    clauses = []
    num_vars = int(num_vars)
    print(f'outer_var_ptr: {outer_var_ptr}')
    for node in nodes:
        if node > num_vars:
            neighbors = list(graph.neighbors(node))
            clause = ""
            assert (len(neighbors) > 0)
            for var in neighbors:
                weight = graph.edges[node, var]['weight']
                if outer_var_ptr and var < 0:
                    var = num_vars + var + 3
                if weight == 1:
                    clause += "{} ".format(var)
                else:
                    assert (weight == -1)
                    clause += "{} ".format(-var)
            clause += "0\n"
            clauses.append(clause)
    if outer_var_ptr:
        num_vars = num_vars - outer_var_ptr - 2
    with open(save_name, 'w') as out_file:
        out_file.write("c generated by satgm vcg\n")
        out_file.write("p cnf {} {}\n".format(num_vars, len(clauses)))
        for clause in clauses:
            out_file.write(clause)
    return

